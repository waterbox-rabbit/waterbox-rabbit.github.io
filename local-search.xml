<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机基础——解释型语言和编译型语言</title>
    <link href="/2021/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80/"/>
    <url>/2021/06/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>每个程序都是一组指令，无论是添加两个数字还是通过互联网发送请求。编译器和解释器将人类可读的代码转换为计算机可读的机器代码。</p><p>对于编译型语言，目标计算机以编译语言直接翻译程序。而对于解释型语言，源代码不会直接由目标计算机翻译，而是由 <em>另一个</em> 程序（即解释器）读取并执行代码。</p><h3 id="好吧…那么这到底是什么意思呢？"><a href="#好吧…那么这到底是什么意思呢？" class="headerlink" title="好吧…那么这到底是什么意思呢？"></a><strong>好吧…那么这到底是什么意思呢？</strong></h3><p>想象你要制作一个鹰嘴豆泥食谱，但是它是用古希腊语写的。你不会讲古希腊语言，你可以通过两种方式遵循其指示。首先是有人已经为你翻译成英文，你（以及其他会说英语的人）可以阅读食谱的英语版本，做鹰嘴豆泥。那么翻译的配方就是 <em>编译版本</em>。第二种方法是，如果你有一位了解古希腊语的朋友，当你准备制作鹰嘴豆泥时，你的朋友会坐在你的旁边，将菜谱逐行翻译成英语。在这种情况下，你的朋友是食谱 <em>解释版本</em> 的解释者。</p><h3 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a><strong>编译型语言</strong></h3><p>编译语言直接转换为处理器可以执行的机器代码。结果，它们会比解释语言更快更高效地执行。 它们还使开发人员可以更好地控制硬件方面，例如内存管理和 CPU 使用率。</p><p>编译语言需要一个“构建”步骤——首先需要手动对其进行编译。每次需要进行更改时，你都需要“重建”程序。在鹰嘴豆泥示例中，整个编译是在呈现给你之前进行的。如果原始作者决定他要使用其他种类的橄榄油，则需要重新翻译整个食谱并重新发送给你。</p><p>纯编译语言的示例是 C，C ++，Erlang，Haskell，Rust 和 Go。</p><h3 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a><strong>解释型语言</strong></h3><p>翻译员逐行执行程序的每个命令。在这里，如果作者决定使用其他种类的橄榄油，则可以将旧的橄榄油划掉，然后添加新的橄榄油。然后，你的翻译朋友可以随时将更改传达给你。</p><p>解释型语言曾经比编译型语言慢很多。但是，随着<a href="https://www.freecodecamp.org/news/just-in-time-compilation-explained/">即时编译</a>的发展，这种差距正在缩小。</p><p>常见的解释语言的示例是 PHP，Ruby，Python 和 JavaScript。</p><h3 id="一个小提醒"><a href="#一个小提醒" class="headerlink" title="一个小提醒"></a><strong>一个小提醒</strong></h3><p>大多数编程语言可以同时具有编译和解释的实现——语言本身不一定是编译或解释的。但是，为简单起见，通常将其简称为某一类。</p><p>例如，Python 可以在交互模式下作为编译程序或解释语言执行。另一方面，大多数命令行工具，CLI 和 shells 在理论上可以归类为解释语言。</p><h2 id="优势和劣势"><a href="#优势和劣势" class="headerlink" title="优势和劣势"></a><strong>优势和劣势</strong></h2><h3 id="编译型语言的优势"><a href="#编译型语言的优势" class="headerlink" title="编译型语言的优势"></a><strong>编译型语言的优势</strong></h3><p>编译为本地机器代码的程序往往比解释的代码要快。这是因为在运行时翻译代码的过程增加了开销，并可能导致程序整体变慢。</p><h3 id="编译型语言的劣势"><a href="#编译型语言的劣势" class="headerlink" title="编译型语言的劣势"></a><strong>编译型语言的劣势</strong></h3><p>最突出的两点劣势是：</p><ul><li>在测试之前完成整个编译步骤需要额外的时间</li><li>生成的二进制代码对平台的依赖性</li></ul><h3 id="解释型语言的优势"><a href="#解释型语言的优势" class="headerlink" title="解释型语言的优势"></a><strong>解释型语言的优势</strong></h3><p>解释型语言更加灵活，并且通常具有诸如动态键入和程序较小的特点。另外，由于解释器自己执行源程序代码，因此代码本身相对于平台是独立的。</p><h3 id="解释型语言的劣势"><a href="#解释型语言的劣势" class="headerlink" title="解释型语言的劣势"></a><strong>解释型语言的劣势</strong></h3><p>与编译型语言相比，其最明显的缺点在于执行速度。</p></br></br><blockquote><p>原文：<a href="https://www.freecodecamp.org/news/compiled-versus-interpreted-languages/">Interpreted vs Compiled Programming Languages: What’s the Difference</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数据结构（6）——二叉树的遍历</title>
    <link href="/2021/06/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2021/06/07/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列将参照《数据结构(C语言版)》第2版 (严蔚敏等) ，使用 JavaScript 的方式复现书中的代码，以用于复习数据结构和 ES 语法。本文对应书中第五章 树与二叉树 的第五节内容。</p></blockquote><h2 id="遍历二叉树的操作定义"><a href="#遍历二叉树的操作定义" class="headerlink" title="遍历二叉树的操作定义"></a>遍历二叉树的操作定义</h2><p>先序遍历二叉树的操作定义如下： 若二叉树为空，则空操作；否则：</p><ul><li>访问根结点；</li><li>先序遍历左子树；</li><li>先序遍历右子树。 </li></ul><p>中序遍历二叉树的操作定义如下： 若二叉树为空，则空操作；否则：</p><ul><li>中序遍历左子树；</li><li>访问根结点；</li><li>中序遍历右子树。 </li></ul><p>后序遍历二叉树的操作定义如下： 若二叉树为空，则空操作；否则：</p><ul><li>后序遍历左子树；</li><li>后序遍历右子树；</li><li>访问根结点。</li></ul><p><img src="/post_img/jsA6/1.png"></p><p>若先序遍历此二叉树，按访间结点的先后如字将结点排列起来，可得到二叉树的先序序列为 -+ a * b -cd /ef ；类似地，中序遍历此二叉树，可得此二叉树的中序序列为 a + b * c - d - e/f ；后序遍历此二叉树，可得此二叉树的后序序列为 abed-*+ ef/ -。</p><h2 id="遍历二叉树的代码实现及衍生算法"><a href="#遍历二叉树的代码实现及衍生算法" class="headerlink" title="遍历二叉树的代码实现及衍生算法"></a>遍历二叉树的代码实现及衍生算法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InOrderTraverse</span>(<span class="hljs-params">tree</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (tree == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    InOrderTraverse(tree.left);<br>    <span class="hljs-built_in">console</span>.log(tree.value);<br>    InOrderTraverse(tree.right);<br>&#125;<br><br><span class="hljs-comment">//按照前序遍历顺序创建新的二叉树</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CreateBiTree</span>(<span class="hljs-params">char</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> char1 = char.shift();<br>    <span class="hljs-keyword">if</span> (char1 == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>        tree = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> tree = <span class="hljs-keyword">new</span> Tree(char1);<br>        tree.left = CreateBiTree(char);<br>        tree.right = CreateBiTree(char);<br>        <span class="hljs-keyword">return</span> tree;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//返回一个拷贝树对象</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CopyTree</span>(<span class="hljs-params">copyTree</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (copyTree == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> newTree = <span class="hljs-keyword">new</span> Tree(copyTree.value);<br>        newTree.left = CopyTree(copyTree.left);<br>        newTree.right = CopyTree(copyTree.right);<br>        <span class="hljs-keyword">return</span> newTree;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测量树的深度</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Depth</span>(<span class="hljs-params">tree</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (tree) &#123;<br>        <span class="hljs-keyword">let</span> leftDepth = Depth(tree.left);<br>        <span class="hljs-keyword">let</span> rightDepth = Depth(tree.right);<br>        <span class="hljs-keyword">if</span> (leftDepth &gt; rightDepth) <span class="hljs-keyword">return</span> leftDepth + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> rightDepth + <span class="hljs-number">1</span>;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> tree1 = <span class="hljs-keyword">new</span> Tree(<span class="hljs-number">1</span>);<br>tree1.left = <span class="hljs-keyword">new</span> Tree(<span class="hljs-number">2</span>);<br>tree1.right = <span class="hljs-keyword">new</span> Tree(<span class="hljs-number">3</span>);<br>tree1.left.left = <span class="hljs-keyword">new</span> Tree(<span class="hljs-number">4</span>);<br>tree1.left.right = <span class="hljs-keyword">new</span> Tree(<span class="hljs-number">5</span>);<br>tree1.right.left = <span class="hljs-keyword">new</span> Tree(<span class="hljs-number">6</span>);<br>tree1.right.right = <span class="hljs-keyword">new</span> Tree(<span class="hljs-number">7</span>);<br>InOrderTraverse(tree1); <span class="hljs-comment">//42516375</span><br><span class="hljs-built_in">console</span>.log(Depth(tree1)); <span class="hljs-comment">//3</span><br><br><span class="hljs-keyword">let</span> arr = <span class="hljs-string">&#x27;12##3##&#x27;</span>.split(<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-keyword">let</span> tree3 = CreateBiTree(arr);<br>InOrderTraverse(tree3); <span class="hljs-comment">//213</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数据结构（5）——树与二叉树的术语和性质</title>
    <link href="/2021/06/03/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%AF%E8%AF%AD%E5%92%8C%E6%80%A7%E8%B4%A8/"/>
    <url>/2021/06/03/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%AF%E8%AF%AD%E5%92%8C%E6%80%A7%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列将参照《数据结构(C语言版)》第2版 (严蔚敏等) ，使用 JavaScript 的方式复现书中的代码，以用于复习数据结构和 ES 语法。本文对应书中第五章 树与二叉树 的前四节内容。</p></blockquote><h2 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h2><p><img src="/post_img/jsA5/1.png"></p><p><strong>结点</strong>：树中的一个独立单元。包含一个数据元素及若于指向其子树的分支，如图中的 A、B、C、D 等。</p><p><strong>结点的度</strong>：结点拥有的子树数称为结点的度。例如，A 的度为 3，C 的度为 1，F 的度为 0。</p><p><strong>树的度</strong>：树的度是树内各结点度的最大值。图所示的树的度为 3。</p><p><strong>叶子</strong>：度为 0 的结点称为叶子或终端结点。结点 K、L、F、G、M、I、J 都是树的叶子。</p><p><strong>非终端结点</strong>：度不为 0 的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。</p><p><strong>双亲和孩子</strong>：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。例如，B 的双亲为 A，B 孩子有 E 和 F。</p><p><strong>兄弟</strong>：同一个双亲的孩子之间互称兄弟。例如 H、I 和 J 互为兄弟。</p><p><strong>祖先</strong>：从根到该结点所经分支上的所有结点。例如 M 的祖先为 A、D 和 H。</p><p><strong>子孙</strong>：以某结点为根的子树中的任一结点都称为该结点的子孙。如 B 的子孙为 E、K、L 和 F。</p><p><strong>层次</strong>：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等千其双亲结点的层次加 1。</p><p><strong>堂兄弟</strong>：双亲在同一层的结点互为堂兄弟。例如，结点 G 与 E、F、H、I、J 互为堂兄弟。</p><p><strong>树的深度</strong>：树中结点的最大层次称为树的深度或高度。图所示的树的深度为 4。</p><p><strong>有序树和无序树</strong>：如果将树中结点的各子树看成从左至右是有次序的（即不能互换）则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。</p><p><strong>森林</strong>：是 m 棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。</p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p><strong>性质1</strong> 在二叉树的第 i 层至多有 2^(i －1) 个结点。(i &gt;= 1)</p><p><strong>性质2</strong> 深度为 k 的二叉树至多有 2^k - 1 个结点。(k &gt;= 1)</p><p><strong>性质3</strong> 对任何一棵二叉树 T，如果其叶结点数为 n0，度为 2 的结点数为 n2，则 n0 ＝n2＋1。</p><p><strong>性质4</strong> 具有 n 个结点的完全二叉树的深度为 [log(2)n] + 1。（其中 [] 表示向下取整）</p><p><strong>性质5</strong>  如将一棵有 n 个结点的完全二叉树自顶向下，同层自左向右连续为结点编号 0，1，…，n - 1，则有： </p><ul><li><p>若 i = 0，则 i 无双亲,  若 i &gt; 0，则 i 的双亲为 [(i -1) / 2]。</p></li><li><p>若 2i + 1 &lt; n，则 i 的左子女为 2i + 1，若 2i + 2 &lt; n，则 i 的右子女为 2i + 2。</p></li><li><p>若结点编号 i 为偶数，且 i != 0，则左兄弟结点 i - 1。</p></li><li><p>若结点编号 i 为奇数，且 i != n - 1，则右兄弟结点为 i + 1。</p></li><li><p>结点 i 所在层次为 [log(2)(i + 1)]。</p></li></ul></br><p><strong>满二叉树</strong>：深度为 K 且含有 2^k - 1 个结点的二叉树。 图左所示是一棵深度为 4 的满二叉树。</p><p><strong>完全二叉树</strong>：深度为 K 的，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从 1 至 n 的结点一一对应时，称之为完全二叉树。图右所示为一棵深度为 4 的完全二叉树。</p><p><img src="/post_img/jsA5/2.png"></p><p>完全二叉树的特点是：</p><ul><li>叶子结点只可能在层次最大的两层上出现；</li><li>对任一结点，若其右分支下的子孙的最大层次为 i，则其左分支下的子孙的最大层次必为 i 或 i + 1。 图中 C 和 D 不是完全二叉树。</li></ul><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><p>顺序存储结构使用一组地址连续的存储单元来存储数据元素，为了能够在存储结构中反映出结点之间的逻辑关系，必须将二叉树中的结点依照一定的规律安排在这组单元中。对于完全二叉树，只要从根起按层序存储即可，依次自上而下、自左至右存储结点元素，即将完全二叉树上编号为 i 的结点元素存储在如上定义的一维数组中下标为 i - 1 的分量中。以下的完全二叉树是按照上一个图的完全二叉树进行存储的：</p><p><img src="/post_img/jsA5/3.png"></p><p>顺序存储结构仅适用于完全二叉树。因为，在最坏的情况下，一个深度为 K 且只有 K 个结点的单支树（树中不存在度为 2 的结点）却需要长度为 2^k - 1 的一维数组。这造成了存储空间的极大浪费，所以对于一般二叉树，更适合采取链式存储结构。</p><p><img src="/post_img/jsA5/4.png"></p><p>在不同的存储结构中，实现二叉树的操作方法也不同，如找结点 x 的双亲，在三叉链表中很容易实现，而在二叉链表中则需从根指针出发巡查。由此，在具体应用中采用什么存储结构，除根据二叉树的形态之外还应考虑需进行何种操作。在以后的二叉树遍历及其应用的算法将采用二叉链表形式实现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数据结构（4）——栈与队列的应用2</title>
    <link href="/2021/06/02/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A82/"/>
    <url>/2021/06/02/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列将参照《数据结构(C语言版)》第2版 (严蔚敏等) ，使用 JavaScript 的方式复现书中的代码，以用于复习数据结构和 ES 语法。本文对应书中第三章 栈和队列 的第六节内容，即案列分析与实现。</p></blockquote><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>任何一个表达式都是由操作数 (operand)、运算符 (operator) 和界限符 (delimiter) 组成的，统称它们为单词。一般地，操作数既可以是常数，也可以是被说明为变量或常量的标识符；运算符可以分为算术运算符、关系运算符和逻辑运算符 3 类；基本界限符有左右括号和表达式结束符等。为了叙述的简洁，在此仅讨论简单算术表达式的求值问题，这种表达式只含加、减、乘、除 4 种运算符。</p></br><p>我们知道，算术四则运算遵循以下 3 条规则：</p><ul><li>先乘除，后加减；</li><li>从左算到右；</li><li>先括号内，后括号外。 </li></ul></br><p>根据上述 3 条运算规则，在运算的每一步中，任意两个相继出现的算符 A 和 B 之间的优先关系，至多是大于、小于和等于。表中定义了这种优先关系：</p><p><img src="/post_img/jsA42/1.png"></p><p><em>没错，我就是这么懒(<del>￣▽￣)</del></em></p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>初始化 OPTR 栈和 OPND 栈，将表达式起始符 “#” 压入OPTR栈。</p><p>扫描表达式，读入第一个字符 ch,，如果表达式没有扫描完毕至 “#” 或 OPTR 的栈顶元素不为 “#” 时，则循环执行以下操作：</p><ul><li><p>若 ch 不是运算符，则压入 OPND 栈，读入下一字符 ch；</p></li><li><p>若 ch 是运算符，则根据 OPTR 的栈顶元素和 ch 的优先级比较结果，做不同的处理；</p><ul><li><p>若是小于，则 ch 压入 OPTR 栈，读入下一字符 ch；</p></li><li><p>若是大于，则弹出 OPTR 栈顶的运算符，从 OPND 栈弹出两个数，进行相应运算，结果压入 OPND 栈；</p></li><li><p>若是等于，则 OPTR 的栈顶元素是 “(“ 且 ch 是 “)” 这时弹出 OPTR 栈顶的 “(“，相当于括号匹配成功，然后读入下一字符 ch。</p></li></ul></li></ul><p>OPND 栈顶元素即为表达式求值结果，返回此元素。</p><h2 id="算法实现与分析"><a href="#算法实现与分析" class="headerlink" title="算法实现与分析"></a>算法实现与分析</h2><p>首先为了方便起见，包装一个用于简单运算和用于比较运算符优先级的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//运算函数</span><br><span class="hljs-comment">//注意这里面传入的第一个num被放在了第二位，这是因为栈的位置导致的问题</span><br><span class="hljs-comment">//例如 4 - 1，入栈后出栈的顺序先是1后是4，所以第一个pop的数字应该被放在第二位</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Calculation</span>(<span class="hljs-params">num2, operator, num1</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (operator) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br>      <span class="hljs-keyword">return</span> num1 + num2;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br>      <span class="hljs-keyword">return</span> num1 - num2;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span>:<br>      <span class="hljs-keyword">return</span> num1 * num2;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:<br>      <span class="hljs-keyword">return</span> num1 / num2;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//在主函数中会定义以下的对象用于映射符号到数字上</span><br><span class="hljs-comment">//let operatorSign = &#123; &quot;+&quot;: 0, &quot;-&quot;: 1, &quot;*&quot;: 2, &quot;/&quot;: 3, &quot;(&quot;: 4, &quot;)&quot;: 5, &quot;#&quot;: 6 &#125;;</span><br><span class="hljs-comment">//这样使用函数的时候传入的是数字，传出的也是数字</span><br><span class="hljs-comment">//为什么要这么设计呢？我也不知道，写完了才觉得这么写显得很傻(~￣▽￣)~</span><br><br><span class="hljs-comment">//比较两个符号的优先级，其中1表示op1优先，0表示op2优先，-1表示优先级相等</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">operationComparison</span>(<span class="hljs-params">op1, op2</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> operatorComparisonArray = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>],<br>  ];<br><br>  <span class="hljs-keyword">return</span> operatorComparisonArray[op1][op2];<br>&#125;<br></code></pre></td></tr></table></figure></br><p>然后实现主函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//主函数实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EvaluateExpression</span>(<span class="hljs-params">expression</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> operatorSign = &#123; <span class="hljs-string">&quot;+&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;-&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;*&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;/&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;(&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&quot;)&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;#&quot;</span>: <span class="hljs-number">6</span> &#125;;<br>  <span class="hljs-comment">//储存数字的栈</span><br>  <span class="hljs-keyword">let</span> numStack = [];<br>  <span class="hljs-comment">//储存运算符的栈</span><br>  <span class="hljs-keyword">let</span> operatorStack = [];<br>  <span class="hljs-comment">//默认输入的表达式字符串中数字和符号用空格隔开且语法符合规则</span><br>  <span class="hljs-keyword">let</span> formulaArr = expression.split(<span class="hljs-string">&quot; &quot;</span>);<br>  <span class="hljs-comment">//读入第一个字符</span><br>  <span class="hljs-keyword">let</span> char = formulaArr.shift();<br>  <span class="hljs-comment">//将#压入栈中</span><br>  operatorStack.push(<span class="hljs-string">&quot;#&quot;</span>);<br><br>  <span class="hljs-comment">//只有当栈底为#同时读入的字符为#才停止循环</span><br>  <span class="hljs-keyword">while</span> (char != <span class="hljs-string">&quot;#&quot;</span> || operatorStack[operatorStack.length - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>    <span class="hljs-comment">//如果字符不是运算符，则压入数字栈，并读取下一个字符</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.keys(operatorSign).includes(char)) &#123;<br>      numStack.push(<span class="hljs-built_in">parseFloat</span>(char));<br>      char = formulaArr.shift();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">switch</span> (<br>      operationComparison(operatorSign[operatorStack[operatorStack.length - <span class="hljs-number">1</span>]], operatorSign[char])<br>      ) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>          <span class="hljs-comment">//应该注意这里并没有读入下一个字符</span><br>          <span class="hljs-comment">//因为运算符栈内可能不止一个运算符，可能有许多个，需要用读入的字符依次与栈内的运算符进行比较</span><br>          <span class="hljs-comment">//直到栈内的运算符小于等于新字符的优先级，压入新字符，或者与同优先级的运算符消掉</span><br>          numStack.push(<br>            Calculation(numStack.pop(), operatorStack.pop(), numStack.pop())<br>          );<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>          operatorStack.push(char);<br>          char = formulaArr.shift();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> -<span class="hljs-number">1</span>:<br>          operatorStack.pop();<br>          char = formulaArr.shift();<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//最终数字栈栈顶即为结果</span><br>  <span class="hljs-built_in">console</span>.log(numStack.pop());<br>&#125;<br><br><span class="hljs-comment">//末尾一定要加#，否则会陷入死循环</span><br>EvaluateExpression(<span class="hljs-string">&quot;1 + 1 #&quot;</span>); <span class="hljs-comment">//2</span><br>EvaluateExpression(<span class="hljs-string">&quot;( 1 + 1 ) * 10 / 5 - 10 #&quot;</span>); <span class="hljs-comment">//-6</span><br></code></pre></td></tr></table></figure></br><p>我个人觉得算式末尾加一个 # 让人不爽，同时开头读入第一个字符和压 # 入栈让整个函数没有了整体性，所以个人在此基础上做了进一步考虑：将传入的算式划分成为符号数组，例如 [‘1’, ‘+’, ‘1’ ]，然后逐个符号遍历。但通过第一种实现方法可以知道，当栈顶运算符的优先级大于输入字符，将栈顶运算符pop运算后，并不会立刻读入新字符，而是将比较后的新字符与新的栈顶运算符再次比较，直到栈顶运算符的优先级小于等于新字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EvaluateExpression2</span>(<span class="hljs-params">expression</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> operatorSign = &#123; <span class="hljs-string">&quot;+&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;-&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;*&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;/&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;(&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&quot;)&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;#&quot;</span>: <span class="hljs-number">6</span> &#125;;<br>  <span class="hljs-keyword">let</span> numStack = [];<br>  <span class="hljs-keyword">let</span> operatorStack = [];<br><br>  <span class="hljs-comment">//读入算式后划分为符号数组遍历</span><br>  <span class="hljs-comment">//例如传入1 + 1，那么就会遍历[&#x27;1&#x27;, &#x27;+&#x27;, &#x27;1&#x27;]</span><br>  expression.split(<span class="hljs-string">&#x27; &#x27;</span>).forEach(<span class="hljs-function"><span class="hljs-params">char</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//如果符号是非运算符，则压入数字栈</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.keys(operatorSign).includes(char)) numStack.push(<span class="hljs-built_in">parseFloat</span>(char));<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">//这里设置一个只能通过break才能脱出的循环，当栈内运算符小于等于新字符或者栈内为空时，才会脱出循环并读入新字符</span><br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (operatorStack.length == <span class="hljs-number">0</span>) &#123; operatorStack.push(char); <span class="hljs-keyword">break</span>; &#125;<br>        <span class="hljs-comment">//获取比较的结果</span><br>        <span class="hljs-keyword">let</span> compareTemp;<br>        <span class="hljs-keyword">if</span> (operatorStack.length != <span class="hljs-number">0</span>)<br>          compareTemp = operationComparison(operatorSign[operatorStack[operatorStack.length - <span class="hljs-number">1</span>]], operatorSign[char]);<br>        <span class="hljs-comment">//当栈内运算符大于新字符的优先级，运算并继续进行循环，直到出现其他情况</span><br>        <span class="hljs-keyword">if</span> (compareTemp == <span class="hljs-number">1</span>)<br>          numStack.push(Calculation(numStack.pop(), operatorStack.pop(), numStack.pop()));<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (compareTemp == <span class="hljs-number">0</span>) &#123;<br>          operatorStack.push(char);<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>          operatorStack.pop();<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>  &#125;)<br>  <span class="hljs-built_in">console</span>.log(Calculation(numStack.pop(), operatorStack.pop(), numStack.pop()));<br>&#125;<br></code></pre></td></tr></table></figure></br><p><strong>高情商：本题目主要要考虑读入字符的时机问题，思考清楚后就很容易了。</strong></p><p><strong>低情商：坑真nm的多。</strong></p><p><img src="/post_img/jsA42/2.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数据结构（4）——栈与队列的应用</title>
    <link href="/2021/05/31/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2021/05/31/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列将参照《数据结构(C语言版)》第2版 (严蔚敏等) ，使用 JavaScript 的方式复现书中的代码，以用于复习数据结构和 ES 语法。本文对应书中第三章 栈和队列 的第六节内容，即案列分析与实现。</p></blockquote><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>当将一个十进制整数 N 转换为八进制数时，在计算过程中，把 N 与 8 求余得到的八进制数的各位依次进栈，计算完毕后将栈中的八进制数依次出栈输出，输出结果就是待求得的八进制数。</p></br><p>伪代码：</p><ol><li><p>初始化一个空栈 S。</p><ul><li>当十进制数N非零时，循环执行以下操作：</li></ul></li><li><p>把 N 与 8 求余得到的八进制数压入栈 S；</p><ul><li>N 更新为 N 与 8 的商。</li></ul></li><li><p>当栈 S 非空时，循环执行以下操作：</p><ul><li><p>弹出栈顶元素 e；</p></li><li><p>输出 e。</p></li></ul></li></ol></br><p>算法实现，时间复杂度为 O(log n)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//进制转换函数，num表示输入的十进制数字，n为要转换的进制</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">conversion</span>(<span class="hljs-params">num, n</span>) </span>&#123;<br>  <span class="hljs-comment">//十以上进制的超过十的数需要使用数字表示</span><br>  <span class="hljs-keyword">let</span> ref = &#123;<br>    <span class="hljs-number">10</span>: <span class="hljs-string">&quot;a&quot;</span>,<br>    <span class="hljs-number">11</span>: <span class="hljs-string">&quot;b&quot;</span>,<br>    <span class="hljs-number">12</span>: <span class="hljs-string">&quot;c&quot;</span>,<br>    <span class="hljs-number">14</span>: <span class="hljs-string">&quot;d&quot;</span>,<br>    <span class="hljs-number">15</span>: <span class="hljs-string">&quot;e&quot;</span>,<br>    <span class="hljs-number">16</span>: <span class="hljs-string">&quot;f&quot;</span>,<br>    <span class="hljs-number">17</span>: <span class="hljs-string">&quot;g&quot;</span>,<br>    <span class="hljs-number">18</span>: <span class="hljs-string">&quot;h&quot;</span>,<br>  &#125;;<br>  <span class="hljs-keyword">let</span> stack = [];<br>  <span class="hljs-keyword">let</span> output = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">//当num不为零时，执行以下步骤</span><br>  <span class="hljs-keyword">while</span> (num) &#123;<br>    stack.push(num % n); <span class="hljs-comment">//将余数压入栈中</span><br>    num = <span class="hljs-built_in">Math</span>.floor(num / n); <span class="hljs-comment">//取商</span><br>  &#125;<br>  <span class="hljs-comment">//逐个出栈生成结果</span><br>  <span class="hljs-keyword">while</span> (stack.length != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">let</span> e = stack.pop();<br>    <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">in</span> ref) output += ref[e];<br>    <span class="hljs-keyword">else</span> output += e;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(output);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="括号匹配检验"><a href="#括号匹配检验" class="headerlink" title="括号匹配检验"></a>括号匹配检验</h2><p>检验算法借助一个栈，每当读入一个左括号，则直接入栈，等待相匹配的同类右括号；每当读入一个右括号，若与当前栈顶的左括号类型相同，则二者匹配，将栈顶的左括号出栈，直到表达式扫描完毕。</p><p>在处理过程中，还要考虑括号不匹配出错的情况。例如，当出现 (( )[ ])) 这种情况时，由于前面入栈的左括号均已和后面出现的右括号相匹配，栈已空，因此最后扫描的右括号不能得到匹配；出现 [([]) 这种错误，当表达式扫描结束时，栈中还有一个左括号没有匹配；出现 (()]  这种错误显然是栈顶的左括号和最后的右括号不匹配。</p></br><p>伪代码：</p><ol><li><p>初始化一个空栈 S。</p></li><li><p>设置一标记性变量 flag， 用来标记匹配结果以控制循环及返回结果，1 表示正确匹配，0 表示错误匹配，flag 初值为 1。</p></li><li><p>扫描表达式，依次读入字符 ch，如果表达式没有扫描完毕或 flag 非零，则循环执行以下操作：</p><ul><li><p>若 ch是左括号 “[“ 或 “(“ 则将其压入栈；</p></li><li><p>若 ch是右括号 “)” 则根据当前栈顶元素的值分情况考虑：若栈非空且栈顶元素是 “(“ 则正确匹配，否则错误匹配，flag 置为 0；</p></li><li><p>若 ch是右括号 “]” 则根据当前栈顶元素的值分情况考虑：若栈非空且栈顶元素是 “[“ 则正确匹配，否则错误匹配，flag 置为 0。</p></li></ul></li><li><p>退出循环后，如果栈空且 flag 值为 1 则匹配成功，返回 true，否则返回 false。</p></li></ol></br><p>代码实现，时间复杂度和空间复杂度均为 O(n)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//括号匹配</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Matching</span>(<span class="hljs-params">txt</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> ref = &#123; <span class="hljs-string">&quot;&#123;&quot;</span>: <span class="hljs-string">&quot;&#125;&quot;</span>, <span class="hljs-string">&quot;[&quot;</span>: <span class="hljs-string">&quot;]&quot;</span>, <span class="hljs-string">&quot;(&quot;</span>: <span class="hljs-string">&quot;)&quot;</span> &#125;;<br>  <span class="hljs-comment">//栈中最顶层的括号（如果使用自己写的栈类，可以用getStackTop方法）</span><br>  <span class="hljs-keyword">let</span> curBracket = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">let</span> stack = [];<br>  <span class="hljs-comment">//Javascript中的forEach方法无法return或break，所以设定一个flag来判断输入的括号是否匹配</span><br>  <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">//将输入的字符串分割成单字符数组并遍历</span><br>  txt.split(<span class="hljs-string">&quot;&quot;</span>).forEach(<span class="hljs-function">(<span class="hljs-params">char</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//如果是左括号，则压入栈中</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(ref).includes(char)) &#123;<br>      stack.push(char);<br>      curBracket = char;<br>    &#125;<br><br>    <span class="hljs-comment">//如果是右括号，則匹配棧中最頂層的括號</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.values(ref).includes(char)) &#123;<br>      <span class="hljs-keyword">if</span> (char == ref[curBracket]) &#123;<br>        stack.pop();<br>        stack.length &gt; <span class="hljs-number">0</span><br>          ? (curBracket = stack[stack.length - <span class="hljs-number">1</span>])<br>          : (curBracket = <span class="hljs-string">&quot;&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> flag = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-comment">//当栈为空，且没有遇到错误时，匹配成功</span><br>  <span class="hljs-keyword">if</span> (stack.length == <span class="hljs-number">0</span> &amp;&amp; flag) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;success!&quot;</span>);<br>  <span class="hljs-keyword">else</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;error!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>艺术流派简介——未来主义</title>
    <link href="/2021/05/31/%E8%89%BA%E6%9C%AF%E6%B5%81%E6%B4%BE%E7%AE%80%E4%BB%8B%E2%80%94%E2%80%94%E6%9C%AA%E6%9D%A5%E4%B8%BB%E4%B9%89/"/>
    <url>/2021/05/31/%E8%89%BA%E6%9C%AF%E6%B5%81%E6%B4%BE%E7%AE%80%E4%BB%8B%E2%80%94%E2%80%94%E6%9C%AA%E6%9D%A5%E4%B8%BB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>”我们会炸掉所有博物馆和图书馆，然后与传统道德、女权主义以及所有的机会主义和功利主义者们做个了断。“</p><p>——《未来主义宣言》</p></blockquote></br><p><img src="/post_img/artSch1/2.jpg"></p><center>“我们宣布，世界的辉煌已被一种新的美所填充：即速度之美！“   ——《未来主义宣言》</center></br><p><strong>未来主义（Futurismo）</strong>是20世纪初起源于意大利的一场艺术和社会运动。它强调活力、速度、技术、青春、暴力以及汽车、飞机和工业城市等物体，旨在抛弃传统，塑造一个崭新的意大利。其关键人物有菲利波·托马索·马里内蒂（Filippo Tommaso Marinetti）和翁贝托·博乔尼（Umberto Boccioni）等。这场艺术运动影响了包括绘画、音乐、建筑和诗歌等诸多方面，同时与意识形态有很大联系。</p><h2 id="未来主义绘画"><a href="#未来主义绘画" class="headerlink" title="未来主义绘画"></a>未来主义绘画</h2><blockquote><p>“应该把万物运动论，作为一种动态感，运用到绘画之中…”   —— Boccioni</p></blockquote><p><img src="/post_img/artSch1/1.jpg"></p><p>《城市的崛起》由意大利的 Umberto Boccioni 在上世纪初期所创作完成。图中高耸的楼房、奔跑的马匹与被挤开而扭曲的人群体现了未来主义中一些最典型的要素：<strong>速度、暴力与科技</strong>。</p><p><img src="/post_img/artSch1/3.jpg"></p><center>Giacomo Balla, 1912, Dinamismo di un Cane al Guinzaglio</center></br><p>未来主义者的画作都体现了他们对感知世界不断运动的坚持。例如这幅画描绘了一只狗，它的腿、尾巴以及遛它的女人的脚都被放大成模糊的运动。它说明了未来主义绘画技术宣言的戒律：“由于图像在视网膜上的停留，运动物体会不断地相互叠加，其形式变化犹如振动。因此奔跑的马不只有四条腿，而可能有二十条。” </p><blockquote><p>未完结</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>艺术流派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数据结构（3）——循环队列和链列</title>
    <link href="/2021/05/29/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E5%88%97/"/>
    <url>/2021/05/29/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%92%8C%E9%93%BE%E5%88%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列将参照《数据结构(C语言版)》第2版 (严蔚敏等) ，使用 JavaScript 的方式复现书中的代码，以用于复习数据结构和 ES 语法。本文对应书中第三章 栈和队列 的第五节内容，即队列部分。</p></blockquote><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>队列的操作与栈的操作类似，不同的是，删除是在表的头部（即队头）进行。和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个整型变最 front 和 rear 分别指示队列头元素及队列尾元素的位置（后面分别称为头指针和尾指针）。</p><p><img src="/post_img/jsA3/3.png"></p><p>为了描述方便起见，在此约定：初始化创建空队列时，令 front = rear = 0, 每当插入新的队列尾元素时，尾指针 rear 增 1；每当删除队列头元素时，头指针 front 增 1。因此在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置，如图所示。</p><p><img src="/post_img/jsA3/1.png"></p><p>我们发现在几次入队出队操作后，队列的实际可用空间未占满，但再次入队会导致溢出，我们成为 “假溢出”。怎样解决这种 “假溢出” 问题呢？一个较巧妙的办法是将顺序队列变为一个环状的空间，如下图所示，称之为<strong>循环队列</strong>。</p><p><img src="/post_img/jsA3/2.png"></p><p>在循环队列中，我们无法通过头指针和尾指针的相等来判断队满的情况，因为队空时头尾指针也是相同的。这时我们可以另设一个标志判断队满，或者少用一个空间元素让 rear 始终指向空白，然后改变判断条件：</p><ul><li>队空的条件：Q.front == Q.rear </li><li>队满的条件：(Q.rear + 1) % MAXSIZE == Q.front</li></ul><p>下面用第二种方法（少用一个空间元素）来实现循环队列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>&#123;<br>  <span class="hljs-comment">//初始化空间大小，用索引来模拟头尾指针</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">MAXSIZE</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.size = MAXSIZE;<br>    <span class="hljs-built_in">this</span>.base = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">this</span>.size);<br>    <span class="hljs-built_in">this</span>.rear = <span class="hljs-built_in">this</span>.front = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//这里考虑了rear与front相减为负的情况</span><br>  <span class="hljs-function"><span class="hljs-title">GetQueueLength</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.rear - <span class="hljs-built_in">this</span>.front + <span class="hljs-built_in">this</span>.size) % <span class="hljs-built_in">this</span>.size;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">EnQueue</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-comment">//判断队满</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">this</span>.rear + <span class="hljs-number">1</span>) % <span class="hljs-built_in">this</span>.size == <span class="hljs-built_in">this</span>.front) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">this</span>.base[<span class="hljs-built_in">this</span>.rear] = value;<br>    <span class="hljs-comment">//当rear位于数组最尾端时，元素入队后将rear指针移回最开头</span><br>    <span class="hljs-built_in">this</span>.rear = (<span class="hljs-built_in">this</span>.rear + <span class="hljs-number">1</span>) % <span class="hljs-built_in">this</span>.size;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">DeQueue</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">//判断队空</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.rear == <span class="hljs-built_in">this</span>.front) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">this</span>.base[<span class="hljs-built_in">this</span>.front] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-built_in">this</span>.front = (<span class="hljs-built_in">this</span>.front + <span class="hljs-number">1</span>) % <span class="hljs-built_in">this</span>.size;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">GetQueueHead</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">//判断队空</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.front == <span class="hljs-built_in">this</span>.rear) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.base[<span class="hljs-built_in">this</span>.front];<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">QueueTraverse</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.base.join(<span class="hljs-string">&quot; -&gt; &quot;</span>));<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> queue1 = <span class="hljs-keyword">new</span> Queue(<span class="hljs-number">6</span>);<br>queue1.EnQueue(<span class="hljs-number">1</span>);<br>queue1.EnQueue(<span class="hljs-number">2</span>);<br>queue1.EnQueue(<span class="hljs-number">3</span>);<br>queue1.EnQueue(<span class="hljs-number">4</span>);<br>queue1.EnQueue(<span class="hljs-number">5</span>);<br>queue1.DeQueue();<br>queue1.EnQueue(<span class="hljs-number">6</span>);<br>queue1.QueueTraverse(); <span class="hljs-comment">// 2 3 4 5 6</span><br></code></pre></td></tr></table></figure><h2 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h2><p>链队是指采用链式存储结构实现的队列。通常链队用单链表来表示。一个链队显然需要两个分别指示队头和队尾的指针（分别称为头指针和尾指针）才能唯一确定。这里和线性表的单链表一样，为了操作方便起见，给链队添加一个头结点，并令头指针始终指向头结点。</p><p><img src="/post_img/jsA3/4.png"></p><p>链队的代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//单节点类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueNode</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.value = value;<br>    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue2</span> </span>&#123;<br>  <span class="hljs-comment">//链队的初始化就不必考虑最大内存的分配问题</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> QueueNode(<span class="hljs-string">&quot;head&quot;</span>); <span class="hljs-comment">//头指针</span><br>    <span class="hljs-built_in">this</span>.front = <span class="hljs-built_in">this</span>.rear = <span class="hljs-built_in">this</span>.head;<br>    <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span>; <span class="hljs-comment">//链队的长度</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">GetQueueLength</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">EnQueue</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-comment">//链队的入队不用考虑队满的情况</span><br>    <span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> QueueNode(value);<br>    <span class="hljs-built_in">this</span>.rear.next = temp;<br>    <span class="hljs-built_in">this</span>.rear = <span class="hljs-built_in">this</span>.rear.next;<br>    <span class="hljs-built_in">this</span>.length++;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">DeQueue</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">//判断队空</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.front == <span class="hljs-built_in">this</span>.rear) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">this</span>.front.next = <span class="hljs-built_in">this</span>.front.next.next;<br>    <span class="hljs-built_in">this</span>.length--;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">GetQueueHead</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">//判断队空</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.front == <span class="hljs-built_in">this</span>.rear) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.front.next.value;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">QueueTraverse</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">//单链表的遍历</span><br>    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.front.next;<br>    <span class="hljs-keyword">let</span> txt = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">while</span> (cur) &#123;<br>      txt += cur.value + <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>      cur = cur.next;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(txt);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> queue2 = <span class="hljs-keyword">new</span> Queue2();<br>queue2.EnQueue(<span class="hljs-number">1</span>);<br>queue2.EnQueue(<span class="hljs-number">2</span>);<br>queue2.EnQueue(<span class="hljs-number">3</span>);<br>queue2.EnQueue(<span class="hljs-number">4</span>);<br>queue2.EnQueue(<span class="hljs-number">5</span>);<br>queue2.DeQueue();<br>queue2.EnQueue(<span class="hljs-number">6</span>);<br>queue2.QueueTraverse(); <span class="hljs-comment">// 2 3 4 5 6</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数据结构（2）——栈与递归</title>
    <link href="/2021/05/27/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92/"/>
    <url>/2021/05/27/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列将参照《数据结构(C语言版)》第2版 (严蔚敏等) ，使用 JavaScript 的方式复现书中的代码，以用于复习数据结构和ES语法。本文对应书中第三章 栈和队列 的第四节内容，即栈与递归。</p></blockquote><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>所谓递归是指，若在一个函数、过程或者数据结构定义的内部又直接（或间接）出现定义本身的应用，则称它们是递归的，或者是递归定义的。例如斐波那契数列就是递归定义的：</p><blockquote><p>斐波那契数列除第一位和第二位为 1 外，后续位为前两位数字之和。</p><p>1 1 2 3 5 8 13 21</p></blockquote><p><img src="/post_img/jsA2/1.png"></p><p>下面以递归的形式实现斐波那契数列：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//n为要获取的位对应的数字</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fib</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Fib(n - <span class="hljs-number">1</span>) + Fib(n - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(Fib(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 55</span><br></code></pre></td></tr></table></figure><p>这种递归的代码实现方法叫做 “分治法”。采取 “分治法” 进行递归求解的问题需要满足以下三个条件。</p><ul><li> 能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象，并且这些处理对象更小且变化有规律。 </li><li> 可以通过上述转化而使问题简化。 </li><li> 必须有一个明确的递归出口，或称递归的边界。</li></ul><p><img src="/post_img/jsA2/2.png"></p><h2 id="n阶Hanoi塔问题"><a href="#n阶Hanoi塔问题" class="headerlink" title="n阶Hanoi塔问题"></a>n阶Hanoi塔问题</h2><p>假设有 3 个分别命名为 A、 B 和 C 的塔座，在塔座 A 上插有 n 个直径大小各不相同，依小到大编号为 1, 2, … , n 的圆盘。现要求将塔座 A 上的n个圆盘移至塔座 C 上，并仍按同样顺序叠排，圆盘移动时必须遵循下列规则： </p><ul><li>每次只能移动一个圆盘； </li><li>圆盘可以插在 A、B 和 C 中的任一塔座上； </li><li>任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。</li></ul><p><strong>问题分析</strong></p><p>如何实现移动圆盘的操作呢？可以用分治求解的递归方法来解决这个问题。设 A 柱上最初的盘子总数为 n，则当 n = l 时，只要将编号为 1 的圆盘从塔座 A 直接移至塔座 C 上即可；否则，执行以下三步：</p><ul><li>用 C 柱做过渡，将 A 柱上的 (n - 1) 个盘子移到 B 柱上；</li><li>将 A 柱上最后一个盘子直接移到 C 柱上；</li><li>用 A 柱做过渡，将 B 柱上的 (n - 1) 个盘子移到 C 柱上。</li></ul><p>具体过程如图所示：</p><p><img src="/post_img/jsA2/3.png"></p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//用一个全局变量记录移动了多少次，根据计算，n个盘子需要移动2^n - 1次</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Move</span>(<span class="hljs-params">startNode, n, EndNode</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(startNode + <span class="hljs-string">&quot; move &quot;</span> + n + <span class="hljs-string">&quot;  to &quot;</span> + EndNode);<br>    count++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Hanoi</span>(<span class="hljs-params">n, A, B, C</span>) </span>&#123;<br>    <span class="hljs-comment">//如果n=l, 则直接将编号为l的圆盘从A移到C, 不经过B，递归结束。</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) Move(A, n, C);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Hanoi(n - <span class="hljs-number">1</span>, A, C, B);<br>        Move(A, n, C);<br>        Hanoi(n - <span class="hljs-number">1</span>, B, A, C);<br>    &#125;<br>&#125;<br><br>Hanoi(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(count); <span class="hljs-comment">//15</span><br></code></pre></td></tr></table></figure><h2 id="递归算法的时间复杂度"><a href="#递归算法的时间复杂度" class="headerlink" title="递归算法的时间复杂度"></a>递归算法的时间复杂度</h2><p>我们可以使用递归树的方法分析实现斐波那契数列所用的递归算法的时间复杂度：</p><p><img src="/post_img/jsA2/4.png"></p><p>可见，随着 n 的增大，时间复杂度为 O(2^n)，这让我们无法接受。</p><p>我们注意到，用递归计算斐波那契数列会导致同一位的重复计算，例如计算第五位 5 = 3 + 2 的时候，第三位 2 = 1 + 1 就被重算了两次。所以我们可以考虑用数组把算过的数字进行保存，将时间复杂度减小到 O(n)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fibTemp = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fib2</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//要注意索引始终少一</span><br>    <span class="hljs-keyword">if</span> (fibTemp[n - <span class="hljs-number">1</span>] != <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> fibTemp[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> result = Fib2(n - <span class="hljs-number">1</span>) + Fib2(n - <span class="hljs-number">2</span>);<br>        fibTemp[n - <span class="hljs-number">1</span>] = result;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <br>&#125;<br><br><span class="hljs-built_in">console</span>.log(Fib2(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><p>通常在生产环境中很少使用递归算法，排除算法设计本身的因素，递归带来的效率问题主要是函数调用带来的额外开销（函数的入栈出栈），以及栈容量的限制。<strong>最主要的是，自己写的别人可能看不懂。</strong></p><h2 id="递归过程与递归工作栈"><a href="#递归过程与递归工作栈" class="headerlink" title="递归过程与递归工作栈"></a>递归过程与递归工作栈</h2><p>在高级语言编制的程序中，调用函数和被调用函数之间的链接及信息交换需通过栈来进行。通常，当在一个函数的运行期间调用另一个函数时，在运行被调用函数之前，系统需先完成 3 件事：</p><ul><li>将所有的实参、返回地址等信息传递给被调用函数保存；</li><li>为被调用函数的局部变量分配存储区；</li><li>将控制转移到被调函数的入口。 </li></ul><p>而从被调用函数返回调用函数之前，系统也应完成 3 件工作：</p><ul><li>保存被调函数的计算结果；</li><li>释放被调函数的数据区；</li><li>依照被调函数保存的返回地址将控制转移到调用函数。</li></ul><p>为了保证递归函数正确执行，系统需设立一个 “递归工作栈” 作为整个递归函数运行期间使用的数据存储区。每一层递归所需信息构成一个工作记录，其中包括所有的实参、所有的局部变量，以及上一层的返回地址。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数据结构（1）——顺序栈和链栈的实现</title>
    <link href="/2021/05/18/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%92%8C%E9%93%BE%E9%98%9F/"/>
    <url>/2021/05/18/JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%92%8C%E9%93%BE%E9%98%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列将参照《数据结构(C语言版)》第2版 (严蔚敏等) ，使用 JavaScript 的方式复现书中的代码，以用于复习数据结构和 ES 语法。本文对应书中第三章 栈和队列 的前三节内容，即顺序栈和链栈的基本实现。</p></blockquote><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>顺序栈是指利用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针 top 指示栈顶元素在顺序栈中的位置，指针 base 指示栈底位置，stacksize 表示栈的最大容量。</p><p><img src="/post_img/jsA1/1.png"></p><p>顺序栈初始化，入栈，出栈和获取栈顶元素的代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> MAXSIZE = <span class="hljs-number">100</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack2</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">InitStack</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(MAXSIZE); <span class="hljs-comment">//使用Javascript的Array对象构建一个数组空间</span><br>    <span class="hljs-built_in">this</span>.base = <span class="hljs-built_in">this</span>.top = <span class="hljs-number">0</span>; <span class="hljs-comment">//用数组下标来模拟指针</span><br>    <span class="hljs-built_in">this</span>.stacksize = MAXSIZE;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">Push</span>(<span class="hljs-params">num</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.top - <span class="hljs-built_in">this</span>.base == <span class="hljs-built_in">this</span>.stacksize) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Error</span>; <span class="hljs-comment">//判断栈是否已满</span><br>    <span class="hljs-built_in">this</span>.items[top] = num;<br>    top++;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">Pop</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.top == <span class="hljs-built_in">this</span>.base) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Error</span>; <span class="hljs-comment">//判断栈是否为空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[top--];<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">GetTop</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.top == <span class="hljs-built_in">this</span>.base) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Error</span>; <span class="hljs-comment">//判断栈是否为空</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[top - <span class="hljs-number">1</span>]; <span class="hljs-comment">//由于栈顶指针top对应的数组索引等于栈顶元素的索引加一，所以这里要减去一</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>链栈是指采用链式存储结构实现的栈。通常链栈用单链表来表示。由于栈的主要操作是在栈顶插入和删除， 显然以链表的头部作为栈顶是最方便的，而且没必要像单链表那样为了操作方便附加一个头结点。</p><p><img src="/post_img/jsA1/2.png"></p><p>链栈的代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//新建一个StackNode类模拟链表节点，value用来储存值，NextStackNode用于存放指针</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackNode</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.NextStackNode = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack3</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">InitStack</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.base = <span class="hljs-built_in">this</span>.top = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">Push</span>(<span class="hljs-params">num</span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> StackNode(num);<br>        temp.NextStackNode = <span class="hljs-built_in">this</span>.top; <span class="hljs-comment">//让新节点的指针指向原有栈顶，然后让栈顶指针指向新节点，这样新节点就成为新的栈顶</span><br>        <span class="hljs-built_in">this</span>.top = temp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">Pop</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.top == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Error</span>; <span class="hljs-comment">//判断节点是否为空</span><br>        <span class="hljs-keyword">let</span> temp = <span class="hljs-built_in">this</span>.top.value; <span class="hljs-comment">//暂存要Pop的节点的值，在最后返回</span><br>        <span class="hljs-built_in">this</span>.top = <span class="hljs-built_in">this</span>.top.NextStackNode; <span class="hljs-comment">//让指向栈顶的节点指向下一位</span><br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">GetTop</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.top == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Error</span>; <span class="hljs-comment">//判断节点是否为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.top.value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PTA数据结构——Maximum Subsequence Sum（C）</title>
    <link href="/2021/05/11/PTA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94Maximum%20Subsequence%20Sum%EF%BC%88C%EF%BC%89/"/>
    <url>/2021/05/11/PTA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94Maximum%20Subsequence%20Sum%EF%BC%88C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列是 <a href="https://pintia.cn/">https://pintia.cn/</a> 下 “中国大学MOOC-陈越、何钦铭-数据结构-2021夏” 题目集的 JavaScript/ C 解法。</p></blockquote><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p>Given a sequence of <em>K</em> integers{ <em>N</em><sub>1</sub>, <em>N</em><sub>2</sub>, …, <em>N</em><sub>K</sub>}. A continuous subsequence is defined to be { <em>N<sub>i</sub></em>, <em>N<sub>i+1</sub>, …, <em>N<sub>j</sub></em> } where 1≤</em>i<em>≤</em>j<em>≤</em>K*. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.（简单来说就是求最大子列和的升级版：顺便求一下最大子列的第一个和最后一个数字）</p><p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em> numbers, separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">10<br>-10 1 2 3 4 -5 -23 3 7 -21<br></code></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">10 <br></code></pre></td></tr></table></figure><h2 id="C语言代码实现"><a href="#C语言代码实现" class="headerlink" title="C语言代码实现"></a>C语言代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> N;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <span class="hljs-keyword">int</span> List[N];<br>    <span class="hljs-keyword">int</span> curSum = <span class="hljs-number">0</span>,<br>        maxSum = <span class="hljs-number">0</span>,<br>        maxSumStart = <span class="hljs-number">0</span>,<br>        maxSumEnd = N - <span class="hljs-number">1</span>,<br>        curSumStart = <span class="hljs-number">0</span>,<br>    <span class="hljs-comment">//一下判断数列里面是否是全为零且没有正数，若是，则输出0 0 0</span><br>        hasZero = <span class="hljs-number">0</span>,<br>        hasPositive = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;List[i]);<br>        curSum += List[i];<br>        <span class="hljs-keyword">if</span> (List[i] &gt; <span class="hljs-number">0</span> &amp;&amp; !hasPositive) hasPositive = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (List[i] == <span class="hljs-number">0</span> &amp;&amp; !hasZero) hasZero = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (curSum &gt; maxSum) &#123;<br>            maxSum = curSum;<br>            maxSumEnd = i;<br>            maxSumStart = curSumStart;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>) &#123;<br>            curSum = <span class="hljs-number">0</span>;<br>            curSumStart = i + <span class="hljs-number">1</span>;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">if</span> (!hasPositive &amp;&amp; hasZero) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, maxSum, List[maxSumStart], List[maxSumEnd]);<br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>PTA数据结构</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PTA数据结构——最大子列和问题（C）</title>
    <link href="/2021/05/10/PTA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98%EF%BC%88C%EF%BC%89/"/>
    <url>/2021/05/10/PTA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98%EF%BC%88C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列是 <a href="https://pintia.cn/">https://pintia.cn/</a> 下 “中国大学MOOC-陈越、何钦铭-数据结构-2021夏” 题目集的 JavaScript/ C 解法。</p></blockquote><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p>给定  <em>K</em> 个整数组成的序列 { <em>N</em><sub>1</sub>, <em>N</em><sub>2</sub>, …, <em>N</em><sub>K</sub>}，“连续子列”被定义为 { <em>N<sub>i</sub></em>, *N<sub>i+1</sub>, …, <em>N<sub>j</sub></em> }，其中 1 ≤ <em>i</em> ≤ <em>j</em> ≤ <em>K</em>。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列 { -2, 11, -4, 13, -5, -2 }，其连续子列 { 11, -4, 13 } 有最大的和 20。现要求你编写程序，计算给定整数序列的最大子列和。</p><p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p><ul><li>数据1：与样例等价，测试基本正确性；</li><li>数据2：102个随机整数；</li><li>数据3：103个随机整数；</li><li>数据4：104个随机整数；</li><li>数据5：105个随机整数；</li></ul><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出正整数<em>K</em> (≤100000)；第2行给出<em>K</em>个整数，其间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">6<br>-2 11 -4 13 -5 -2<br></code></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">20<br></code></pre></td></tr></table></figure><h2 id="C语言代码实现"><a href="#C语言代码实现" class="headerlink" title="C语言代码实现"></a>C语言代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">//复杂度为 O(n)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> N;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <span class="hljs-keyword">int</span> List[N];<br>    <span class="hljs-keyword">int</span> curSum = <span class="hljs-number">0</span>,<br>        maxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;List[i]);<br>        curSum += List[i];<br>        <span class="hljs-keyword">if</span> (curSum &gt; maxSum) maxSum = curSum;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>) curSum = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, maxSum);<br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>PTA数据结构</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT乙级——1002写出这个数</title>
    <link href="/2021/05/03/PAT%E4%B9%99%E7%BA%A7%E2%80%94%E2%80%941002%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/05/03/PAT%E4%B9%99%E7%BA%A7%E2%80%94%E2%80%941002%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列是 <a href="https://pintia.cn/">https://pintia.cn/</a> 下 “PAT (Basic Level) Practice” 题目集的 JavaScript 解法。</p></blockquote><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p>读入一个正整数 <em>n</em>，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出自然数 <em>n</em> 的值。这里保证 <em>n</em> 小于 10100。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行内输出 <em>n</em> 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中<strong>最后一个拼音数字后没有空格</strong>。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">1234567890987654321123456789<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">yi san wu<br></code></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">var</span> buf = <span class="hljs-string">&#x27;&#x27;</span>;<br>process.stdin.on(<span class="hljs-string">&#x27;readable&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> chunk = process.stdin.read();<br>  <span class="hljs-keyword">if</span> (chunk) buf += chunk.toString();<br>&#125;);<br><span class="hljs-comment">/** 以上是node相关的部分，主要算法实现在下面 **/</span><br><br><span class="hljs-comment">//存储要输出的最终字符串</span><br><span class="hljs-keyword">var</span> result = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-comment">//存储计算出来的数字综合</span><br><span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> ob = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;ling&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;yi&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;er&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-string">&#x27;san&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-string">&#x27;si&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-string">&#x27;wu&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>: <span class="hljs-string">&#x27;liu&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-string">&#x27;qi&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>: <span class="hljs-string">&#x27;ba&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>: <span class="hljs-string">&#x27;jiu&#x27;</span> &#125;<br><br>process.stdin.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//读取输入的文字并按行遍历</span><br>  buf.split(<span class="hljs-string">&#x27;\n&#x27;</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>&#123;<br>    <span class="hljs-comment">//PTA的输入用例有可能输入空格行，所以加以判断</span><br>    <span class="hljs-keyword">if</span> (line == <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//将输入的字符串分离成为单个数字的数组并遍历</span><br>    line.split(<span class="hljs-string">&#x27;&#x27;</span>).forEach(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (num != <span class="hljs-string">&#x27;&#x27;</span>)<br>         sum += <span class="hljs-built_in">parseInt</span>(num); <span class="hljs-comment">//计算总和</span><br>    &#125;)<br>  &#125;);<br>  <span class="hljs-comment">//将总和分离成为单个数字的数字并遍历，找到每个数字对应的汉字</span><br>  sum.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).forEach(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>    result += ob[num] + <span class="hljs-string">&#x27; &#x27;</span>;<br>  &#125;)<br>  <span class="hljs-comment">//根据条件，最终取子串舍去最后一个空格位</span><br>  <span class="hljs-built_in">console</span>.log(result.substring(<span class="hljs-number">0</span>, result.length - <span class="hljs-number">1</span>));<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>PAT乙级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT乙级——1001害死人不偿命的(3n+1)猜想</title>
    <link href="/2021/05/01/PAT%E4%B9%99%E7%BA%A7%E2%80%94%E2%80%941001%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84(3n+1)%E7%8C%9C%E6%83%B3/"/>
    <url>/2021/05/01/PAT%E4%B9%99%E7%BA%A7%E2%80%94%E2%80%941001%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84(3n+1)%E7%8C%9C%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本系列是 <a href="https://pintia.cn/">https://pintia.cn/</a> 下 “PAT (Basic Level) Practice” 题目集的 JavaScript 解法。</p></blockquote><h2 id="1001题目介绍"><a href="#1001题目介绍" class="headerlink" title="1001题目介绍"></a>1001题目介绍</h2><p>卡拉兹 (Callatz) 猜想：</p><p>对任何一个正整数 <em>n</em>，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3<em>n</em>+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 <em>n</em>=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3<em>n</em>+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p><p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 <em>n</em>，简单地数一下，需要多少步（砍几下）才能得到 <em>n</em>=1？</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出正整数 <em>n</em> 的值。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出从 <em>n</em> 计算到 1 需要的步数。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">5<br></code></pre></td></tr></table></figure><h2 id="1001代码实现"><a href="#1001代码实现" class="headerlink" title="1001代码实现"></a>1001代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> readline = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;readline&#x27;</span>);<br><span class="hljs-keyword">var</span> rl = readline.createInterface(&#123;<br>  <span class="hljs-attr">input</span>: process.stdin,<br>  <span class="hljs-attr">output</span>: process.stdout<br>&#125;);<br>rl.on(<span class="hljs-string">&#x27;line&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-comment">//用i来记录步数</span><br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (num != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) num = num / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span> num = (<span class="hljs-number">3</span> * num + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        i++;<br>        &#125;<br>    <span class="hljs-built_in">console</span>.log(i);<br>    rl.close();<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="1005题目介绍"><a href="#1005题目介绍" class="headerlink" title="1005题目介绍"></a>1005题目介绍</h2><p>卡拉兹 (Callatz) 猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p><p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 <em>n</em>=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 <em>n</em>=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 <em>n</em> 为“关键数”，如果 <em>n</em> 不能被数列中的其他数字所覆盖。</p><p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p><h3 id="输入格式：-1"><a href="#输入格式：-1" class="headerlink" title="输入格式："></a>输入格式：</h3><p>每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 <em>K</em> (&lt;100)，第 2 行给出 <em>K</em> 个互不相同的待验证的正整数 <em>n</em> (1&lt;<em>n</em>≤100)的值，数字间用空格隔开。</p><h3 id="输出格式：-1"><a href="#输出格式：-1" class="headerlink" title="输出格式："></a>输出格式：</h3><p>每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。</p><h3 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">6<br>3 5 6 7 8 11<br></code></pre></td></tr></table></figure><h3 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">7 6<br></code></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">var</span> buf = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>process.stdin.on(<span class="hljs-string">&#x27;readable&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> chunk = process.stdin.read();<br>    <span class="hljs-keyword">if</span> (chunk) buf += chunk.toString();<br>&#125;);<br><br>process.stdin.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> result = []; <span class="hljs-comment">//存储关键数</span><br>    <span class="hljs-keyword">let</span> arr2 = []; <span class="hljs-comment">//存储输入的数组</span><br>    <span class="hljs-keyword">let</span> arr = [];  <span class="hljs-comment">//存储输入的数组对应覆盖的数</span><br>    <span class="hljs-keyword">let</span> isFirstLine = <span class="hljs-literal">true</span>;<br>    buf.split(<span class="hljs-string">&#x27;\n&#x27;</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">line</span>) </span>&#123;<br>        <span class="hljs-comment">//防止实例输入空行</span><br>        <span class="hljs-keyword">if</span> (line == <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//不需要第一行</span><br>        <span class="hljs-keyword">if</span> (isFirstLine) &#123;<br>            isFirstLine = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        line.split(<span class="hljs-string">&#x27; &#x27;</span>).forEach(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (num.trim() != <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>                <span class="hljs-comment">//将初始数扔进arr2</span><br>                arr2.push(num);<br>                <span class="hljs-keyword">let</span> num1 = <span class="hljs-built_in">parseInt</span>(num);<br>                <span class="hljs-comment">//计算数组中的数对应的覆盖数，填充进arr</span><br>                <span class="hljs-keyword">while</span> (num1 != <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (num1 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123; num1 = num1 / <span class="hljs-number">2</span>; <span class="hljs-keyword">if</span> (num1 != <span class="hljs-number">1</span>) arr.push(num1); &#125;<br>                    <span class="hljs-keyword">else</span> &#123; num1 = (<span class="hljs-number">3</span> * num1 + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-keyword">if</span> (num1 != <span class="hljs-number">1</span>) arr.push(num1); &#125;<br>                &#125;<br>            &#125;<br>        &#125;)<br>    &#125;);<br>    <span class="hljs-comment">//判断关键数，即在覆盖数数组中找不到的初始数</span><br>    arr2.forEach(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!arr.includes(<span class="hljs-built_in">parseInt</span>(num))) result.push(<span class="hljs-built_in">parseInt</span>(num));<br>    &#125;)<br>    <span class="hljs-comment">//降序排序</span><br>    result.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> b - a;<br>    &#125;)<br>    <span class="hljs-comment">//输出结果</span><br>    <span class="hljs-built_in">console</span>.log(result.join(<span class="hljs-string">&#x27; &#x27;</span>))<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>PAT乙级</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
